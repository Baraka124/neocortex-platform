<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synapse | Thinking Markdown Platform</title>
    
    <!-- Neural Network Visualization -->
    <script src="https://unpkg.com/force-graph"></script>
    
    <!-- Real-time Collaboration -->
    <script src="https://unpkg.com/y-websocket"></script>
    <script src="https://unpkg.com/yjs"></script>
    
    <!-- AI-powered Search -->
    <script src="https://cdn.jsdelivr.net/npm/@huggingface/transformers"></script>
    
    <style>
        :root {
            --bg: #0a0a0a;
            --surface: #1a1a1a;
            --text: #ffffff;
            --accent: #8b5cf6;
            --secondary: #10b981;
            --danger: #ef4444;
            
            --neuron-size: 4px;
            --synapse-speed: 2s;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }
        
        /* Neural Background */
        #neural-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
        }
        
        /* Main Layout */
        .app {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            height: 100vh;
            gap: 1px;
            background: var(--surface);
        }
        
        /* Neural Navigation Panel */
        .neural-panel {
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(139, 92, 246, 0.3);
            padding: 1.5rem;
            overflow-y: auto;
        }
        
        .neuron {
            display: block;
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            background: rgba(139, 92, 246, 0.1);
            border-radius: 8px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .neuron::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(139, 92, 246, 0.2) 50%, 
                transparent 100%);
            transform: translateX(-100%);
        }
        
        .neuron.active {
            background: rgba(139, 92, 246, 0.3);
            border-color: var(--accent);
            transform: translateX(4px);
        }
        
        .neuron:hover::before {
            animation: synapse-flow var(--synapse-speed) ease-in-out;
        }
        
        @keyframes synapse-flow {
            to { transform: translateX(100%); }
        }
        
        /* Content Editor */
        .editor-panel {
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }
        
        .editor-toolbar {
            padding: 1rem;
            background: rgba(26, 26, 26, 0.9);
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .editor-toolbar button {
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.4);
            color: var(--accent);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .editor-toolbar button:hover {
            background: rgba(139, 92, 246, 0.4);
            transform: translateY(-1px);
        }
        
        #markdown-editor {
            flex: 1;
            padding: 2rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.8;
            background: transparent;
            color: var(--text);
            border: none;
            outline: none;
            resize: none;
            overflow-y: auto;
        }
        
        #markdown-editor:focus {
            box-shadow: inset 0 0 0 1px rgba(139, 92, 246, 0.5);
        }
        
        /* AI Panel */
        .ai-panel {
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(16, 185, 129, 0.3);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .ai-section {
            background: rgba(16, 185, 129, 0.1);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        
        .ai-section h3 {
            color: var(--secondary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .ai-suggestion {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .ai-suggestion:hover {
            background: rgba(16, 185, 129, 0.2);
            transform: translateX(4px);
        }
        
        /* Neural Graph Visualization */
        .graph-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        
        /* Floating Controls */
        .floating-controls {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            gap: 1rem;
        }
        
        .control-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--accent);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: 0 8px 32px rgba(139, 92, 246, 0.4);
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 12px 48px rgba(139, 92, 246, 0.6);
        }
        
        /* Neural Connections */
        .connection {
            position: absolute;
            background: linear-gradient(90deg, var(--accent), var(--secondary));
            height: 2px;
            transform-origin: 0 0;
        }
        
        /* Real-time Cursors */
        .remote-cursor {
            position: absolute;
            width: 2px;
            height: 20px;
            background: var(--danger);
            pointer-events: none;
            z-index: 1000;
        }
        
        .cursor-label {
            position: absolute;
            background: var(--danger);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            transform: translateY(-100%);
        }
        
        /* Neural Pulse Animation */
        @keyframes neural-pulse {
            0% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(139, 92, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
        }
        
        .neural-pulse {
            animation: neural-pulse 2s infinite;
        }
    </style>
</head>
<body>
    <!-- Neural Background Canvas -->
    <canvas id="neural-canvas"></canvas>
    
    <!-- Neural Graph Visualization -->
    <div id="graph-container" class="graph-container"></div>
    
    <!-- Main App -->
    <div class="app">
        <!-- Left: Neural Navigation -->
        <div class="neural-panel">
            <h2 style="color: var(--accent); margin-bottom: 1.5rem;">üß† Neural Map</h2>
            
            <div id="neural-navigation">
                <!-- Dynamic neurons will appear here -->
            </div>
            
            <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                <h4 style="color: var(--secondary); margin-bottom: 1rem;">üåÄ Neural Patterns</h4>
                <div id="pattern-detection">
                    <!-- AI-detected patterns -->
                </div>
            </div>
        </div>
        
        <!-- Center: Markdown Editor -->
        <div class="editor-panel">
            <div class="editor-toolbar">
                <button onclick="formatText('**', '**')">Bold</button>
                <button onclick="formatText('*', '*')">Italic</button>
                <button onclick="formatText('# ', '')">H1</button>
                <button onclick="formatText('## ', '')">H2</button>
                <button onclick="formatText('```\n', '\n```')">Code</button>
                <button onclick="formatText('- ', '')">List</button>
                <button onclick="formatText('> ', '')">Quote</button>
                <button onclick="aiComplete()">ü§ñ AI Complete</button>
                <button onclick="saveToGitHub()" style="margin-left: auto;">üíæ Commit</button>
            </div>
            
            <textarea 
                id="markdown-editor" 
                placeholder="# Start typing...\n\nYour thoughts will automatically organize themselves..."
                autofocus
            ></textarea>
        </div>
        
        <!-- Right: AI Assistant -->
        <div class="ai-panel">
            <div class="ai-section">
                <h3>üîç AI Suggestions</h3>
                <div id="ai-suggestions">
                    <!-- AI suggestions appear here -->
                </div>
            </div>
            
            <div class="ai-section">
                <h3>üéØ Related Concepts</h3>
                <div id="related-concepts">
                    <!-- AI-generated connections -->
                </div>
            </div>
            
            <div class="ai-section">
                <h3>üë• Live Collaborators</h3>
                <div id="live-cursors">
                    <!-- Real-time cursors -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Floating Controls -->
    <div class="floating-controls">
        <button class="control-btn neural-pulse" onclick="toggleNeuralView()">üß†</button>
        <button class="control-btn" onclick="exportMindMap()">üì§</button>
        <button class="control-btn" onclick="trainAI()">ü§ñ</button>
        <button class="control-btn" onclick="shareSession()">üåê</button>
    </div>
    
    <!-- WebSocket for real-time collaboration -->
    <script>
        // === CORE: Single File Neural Markdown Platform ===
        
        class SynapsePlatform {
            constructor() {
                this.content = '';
                this.neurons = new Map();
                this.connections = [];
                this.aiModel = null;
                this.collaborators = new Map();
                
                this.init();
            }
            
            async init() {
                // 1. Load from GitHub (or create new)
                await this.loadContent();
                
                // 2. Initialize neural network visualization
                this.initNeuralNetwork();
                
                // 3. Start real-time collaboration
                this.initCollaboration();
                
                // 4. Load AI model for suggestions
                await this.initAI();
                
                // 5. Start analyzing patterns
                this.startPatternAnalysis();
                
                console.log('üß† Synapse Platform Activated');
            }
            
            async loadContent() {
                try {
                    // Try to load from GitHub
                    const response = await fetch('https://api.github.com/repos/YOUR_USER/YOUR_REPO/contents/synapse.md');
                    const data = await response.json();
                    this.content = atob(data.content);
                    document.getElementById('markdown-editor').value = this.content;
                    
                    // Extract neurons (headings)
                    this.extractNeurons();
                    
                } catch (error) {
                    // Start with template
                    this.content = `# My Neural Notes\n\nWelcome to Synapse!\n\n## Quick Start\n- Just type...\n- Ideas auto-organize\n- AI suggests connections\n\n## Today's Thoughts\n\n## Projects\n\n## Ideas\n\n## Research\n`;
                    document.getElementById('markdown-editor').value = this.content;
                    this.extractNeurons();
                }
            }
            
            extractNeurons() {
                const lines = this.content.split('\n');
                this.neurons.clear();
                
                lines.forEach((line, index) => {
                    if (line.startsWith('# ')) {
                        const id = `neuron-${index}`;
                        this.neurons.set(id, {
                            id,
                            title: line.substring(2),
                            content: '',
                            level: 1,
                            position: index,
                            connections: []
                        });
                    } else if (line.startsWith('## ')) {
                        const id = `neuron-${index}`;
                        this.neurons.set(id, {
                            id,
                            title: line.substring(3),
                            content: '',
                            level: 2,
                            position: index,
                            connections: []
                        });
                    }
                });
                
                this.updateNeuralNavigation();
                this.buildConnections();
            }
            
            updateNeuralNavigation() {
                const container = document.getElementById('neural-navigation');
                container.innerHTML = '';
                
                this.neurons.forEach(neuron => {
                    const neuronEl = document.createElement('div');
                    neuronEl.className = 'neuron';
                    neuronEl.innerHTML = `
                        <div style="font-weight: ${neuron.level === 1 ? 'bold' : 'normal'}">
                            ${'#'.repeat(neuron.level)} ${neuron.title}
                        </div>
                        <small style="opacity: 0.6;">${neuron.connections.length} connections</small>
                    `;
                    
                    neuronEl.onclick = () => {
                        document.getElementById('markdown-editor').scrollTop = 
                            neuron.position * 20;
                        
                        // Highlight in neural view
                        this.highlightNeuron(neuron.id);
                    };
                    
                    container.appendChild(neuronEl);
                });
            }
            
            buildConnections() {
                this.connections = [];
                const neurons = Array.from(this.neurons.values());
                
                // Simple connection logic: connect related topics
                for (let i = 0; i < neurons.length; i++) {
                    for (let j = i + 1; j < neurons.length; j++) {
                        const similarity = this.calculateSimilarity(
                            neurons[i].title, 
                            neurons[j].title
                        );
                        
                        if (similarity > 0.3) {
                            this.connections.push({
                                source: neurons[i].id,
                                target: neurons[j].id,
                                strength: similarity
                            });
                            
                            neurons[i].connections.push(neurons[j].id);
                            neurons[j].connections.push(neurons[i].id);
                        }
                    }
                }
                
                this.updateNeuralVisualization();
            }
            
            calculateSimilarity(a, b) {
                const wordsA = new Set(a.toLowerCase().split(/\W+/));
                const wordsB = new Set(b.toLowerCase().split(/\W+/));
                const intersection = new Set([...wordsA].filter(x => wordsB.has(x)));
                return intersection.size / Math.max(wordsA.size, wordsB.size);
            }
            
            initNeuralNetwork() {
                const canvas = document.getElementById('neural-canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Create neural nodes
                const nodes = Array.from(this.neurons.values()).map((neuron, i) => ({
                    id: neuron.id,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: 3 + neuron.connections.length,
                    neuron
                }));
                
                // Animation loop
                const animate = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw connections
                    ctx.strokeStyle = 'rgba(139, 92, 246, 0.3)';
                    ctx.lineWidth = 1;
                    
                    this.connections.forEach(conn => {
                        const source = nodes.find(n => n.id === conn.source);
                        const target = nodes.find(n => n.id === conn.target);
                        
                        if (source && target) {
                            ctx.beginPath();
                            ctx.moveTo(source.x, source.y);
                            ctx.lineTo(target.x, target.y);
                            ctx.stroke();
                        }
                    });
                    
                    // Draw nodes
                    nodes.forEach(node => {
                        // Node glow
                        const gradient = ctx.createRadialGradient(
                            node.x, node.y, 0,
                            node.x, node.y, node.radius * 3
                        );
                        gradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)');
                        gradient.addColorStop(1, 'rgba(139, 92, 246, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.radius * 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Node core
                        ctx.fillStyle = 'rgb(139, 92, 246)';
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Move nodes with force simulation
                    nodes.forEach(node => {
                        // Repel from other nodes
                        nodes.forEach(other => {
                            if (other.id !== node.id) {
                                const dx = other.x - node.x;
                                const dy = other.y - node.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < 100) {
                                    node.x -= dx * 0.01;
                                    node.y -= dy * 0.01;
                                }
                            }
                        });
                        
                        // Attract to center
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        node.x += (centerX - node.x) * 0.001;
                        node.y += (centerY - node.y) * 0.001;
                        
                        // Add random motion
                        node.x += (Math.random() - 0.5) * 2;
                        node.y += (Math.random() - 0.5) * 2;
                        
                        // Keep in bounds
                        node.x = Math.max(10, Math.min(canvas.width - 10, node.x));
                        node.y = Math.max(10, Math.min(canvas.height - 10, node.y));
                    });
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            async initAI() {
                // Load lightweight AI model for suggestions
                try {
                    console.log('Loading AI model...');
                    // Using Transformers.js for in-browser AI
                    // This is a simplified version
                    this.aiModel = {
                        async suggestCompletion(text) {
                            // Simulated AI suggestions
                            const suggestions = [
                                "Consider adding an example here.",
                                "This connects with your earlier point about...",
                                "Would you like to add a code snippet?",
                                "You might want to reference:",
                                "This could be expanded into a new section."
                            ];
                            return suggestions[Math.floor(Math.random() * suggestions.length)];
                        },
                        
                        async findRelatedConcepts(text) {
                            const concepts = [
                                "Machine Learning", "Neural Networks", 
                                "Real-time Collaboration", "Markdown",
                                "Knowledge Graphs", "AI Assistants"
                            ];
                            return concepts.slice(0, 3);
                        }
                    };
                    
                    console.log('AI model ready');
                } catch (error) {
                    console.log('AI model failed to load, using fallback');
                }
            }
            
            initCollaboration() {
                // Real-time collaboration using Yjs
                try {
                    const ydoc = new Y.Doc();
                    const ytext = ydoc.getText('synapse');
                    
                    ytext.observe(event => {
                        const content = ytext.toString();
                        this.content = content;
                        document.getElementById('markdown-editor').value = content;
                        this.extractNeurons();
                    });
                    
                    // Connect to WebSocket server (self-hosted or public)
                    const wsProvider = new yws.WebsocketProvider(
                        'wss://your-websocket-server.com',
                        'synapse-room',
                        ydoc
                    );
                    
                    // Track other users
                    wsProvider.awareness.on('change', () => {
                        this.updateCollaborators(wsProvider.awareness.getStates());
                    });
                    
                } catch (error) {
                    console.log('Collaboration offline');
                }
            }
            
            updateCollaborators(states) {
                const container = document.getElementById('live-cursors');
                container.innerHTML = '';
                
                states.forEach((state, clientId) => {
                    if (state.user) {
                        const cursor = document.createElement('div');
                        cursor.className = 'ai-suggestion';
                        cursor.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <div style="width: 8px; height: 8px; background: var(--danger); border-radius: 50%;"></div>
                                ${state.user.name}
                            </div>
                            <small>Editing: ${state.user.currentSection || 'General'}</small>
                        `;
                        container.appendChild(cursor);
                    }
                });
            }
            
            startPatternAnalysis() {
                // Analyze writing patterns
                setInterval(() => {
                    this.analyzePatterns();
                }, 10000);
            }
            
            analyzePatterns() {
                const container = document.getElementById('pattern-detection');
                const patterns = this.detectPatterns();
                
                container.innerHTML = patterns.map(pattern => `
                    <div class="ai-suggestion">
                        <strong>${pattern.type}</strong>
                        <div style="font-size: 0.8rem; opacity: 0.8;">${pattern.description}</div>
                    </div>
                `).join('');
            }
            
            detectPatterns() {
                const patterns = [];
                const text = this.content.toLowerCase();
                
                if (text.includes('todo') || text.includes('need to')) {
                    patterns.push({
                        type: '‚ö° Action Items',
                        description: 'Found potential tasks'
                    });
                }
                
                if (text.split('\n\n').length > 10) {
                    patterns.push({
                        type: 'üìö Dense Content',
                        description: 'Consider adding more headings'
                    });
                }
                
                if ((text.match(/\?\?/g) || []).length > 3) {
                    patterns.push({
                        type: 'ü§î Questions',
                        description: 'Multiple questions detected'
                    });
                }
                
                return patterns.slice(0, 3);
            }
            
            async generateAISuggestions() {
                const container = document.getElementById('ai-suggestions');
                if (!this.aiModel) return;
                
                const currentText = document.getElementById('markdown-editor').value;
                const suggestion = await this.aiModel.suggestCompletion(currentText);
                
                const suggestionEl = document.createElement('div');
                suggestionEl.className = 'ai-suggestion';
                suggestionEl.innerHTML = suggestion;
                suggestionEl.onclick = () => {
                    document.getElementById('markdown-editor').value += '\n\n' + suggestion;
                };
                
                container.prepend(suggestionEl);
                
                // Keep only 3 suggestions
                const suggestions = container.querySelectorAll('.ai-suggestion');
                if (suggestions.length > 3) {
                    suggestions[3].remove();
                }
            }
            
            highlightNeuron(neuronId) {
                document.querySelectorAll('.neuron').forEach(n => n.classList.remove('active'));
                document.querySelector(`[onclick*="${neuronId}"]`)?.classList.add('active');
            }
        }
        
        // === GLOBAL FUNCTIONS ===
        
        let synapse;
        
        window.onload = () => {
            synapse = new SynapsePlatform();
            
            // Auto-save on changes
            document.getElementById('markdown-editor').addEventListener('input', (e) => {
                synapse.content = e.target.value;
                synapse.extractNeurons();
                
                // Generate AI suggestions
                setTimeout(() => synapse.generateAISuggestions(), 1000);
            });
            
            // Auto-save to localStorage
            setInterval(() => {
                localStorage.setItem('synapse-backup', synapse.content);
            }, 5000);
        };
        
        // Editor formatting
        function formatText(before, after) {
            const editor = document.getElementById('markdown-editor');
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const selected = editor.value.substring(start, end);
            
            editor.value = editor.value.substring(0, start) + 
                          before + selected + after + 
                          editor.value.substring(end);
            
            editor.focus();
            editor.setSelectionRange(start + before.length, end + before.length);
        }
        
        // AI Completion
        async function aiComplete() {
            const editor = document.getElementById('markdown-editor');
            const cursorPos = editor.selectionStart;
            const textBefore = editor.value.substring(0, cursorPos);
            
            // Send to AI for completion
            const completion = await synapse.aiModel?.suggestCompletion(textBefore);
            
            if (completion) {
                editor.value = editor.value.substring(0, cursorPos) + 
                              completion + 
                              editor.value.substring(cursorPos);
            }
        }
        
        // Save to GitHub
        async function saveToGitHub() {
            const content = document.getElementById('markdown-editor').value;
            const encoded = btoa(unescape(encodeURIComponent(content)));
            
            // This would need proper GitHub OAuth in production
            alert('In production: Would commit to GitHub\n\nYou can implement using GitHub API with proper authentication');
            
            // For demo: simulate save
            document.querySelector('.control-btn').style.background = 'var(--secondary)';
            setTimeout(() => {
                document.querySelector('.control-btn').style.background = 'var(--accent)';
            }, 1000);
        }
        
        // Export as mind map
        function exportMindMap() {
            const data = {
                neurons: Array.from(synapse.neurons.values()),
                connections: synapse.connections,
                content: synapse.content
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'synapse-mindmap.json';
            a.click();
        }
        
        // Train AI on your writing
        function trainAI() {
            alert('Training AI on your writing patterns...\n(This would use local ML in production)');
        }
        
        // Share collaborative session
        function shareSession() {
            const sessionId = Math.random().toString(36).substr(2, 9);
            const url = `${window.location.origin}?session=${sessionId}`;
            
            navigator.clipboard.writeText(url);
            alert(`Collaboration link copied!\n\n${url}\n\nShare this link for real-time editing.`);
        }
        
        // Toggle neural view
        function toggleNeuralView() {
            const canvas = document.getElementById('neural-canvas');
            canvas.style.opacity = canvas.style.opacity === '0' ? '0.1' : '0';
        }
    </script>
</body>
</html>
